import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';
import { config } from 'dotenv';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load environment variables from .env.local
const envPath = path.join(__dirname, '../.env.local');
if (fs.existsSync(envPath)) {
  config({ path: envPath });
  console.log('üìÑ Loaded environment variables from .env.local');
} else {
  console.log('‚ö†Ô∏è  No .env.local found, using default values');
}

const BACKEND_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000';
const OPENAPI_ENDPOINT = `${BACKEND_URL}/openapi.json`;
const OUTPUT_FILE = path.join(__dirname, '../src/types/api-generated.types.ts');

async function checkBackendHealth() {
  console.log(`üîç Checking if backend is running at ${BACKEND_URL}...`);

  try {
    const response = await fetch(`${BACKEND_URL}/health`, {
      signal: AbortSignal.timeout(5000),
    });

    if (response.ok) {
      console.log('‚úÖ Backend is running and healthy');
      return true;
    } else {
      console.error(`‚ùå Backend returned status ${response.status}`);
      return false;
    }
  } catch (error) {
    console.error('‚ùå Backend is not running or not accessible');
    console.error('   Please start the backend with: cd Backend_Hono_Clinica && npm run dev');
    return false;
  }
}

async function generateTypesWithCLI() {
  console.log(`üì° Generating types from ${OPENAPI_ENDPOINT}...`);

  try {
    // Use openapi-typescript CLI directly with the URL
    const output = execSync(
      `npx openapi-typescript "${OPENAPI_ENDPOINT}" --export-type`,
      {
        encoding: 'utf-8',
        maxBuffer: 10 * 1024 * 1024,
        stdio: ['inherit', 'pipe', 'pipe']
      }
    );

    console.log(`‚úÖ Types generated successfully`);
    return output;
  } catch (error: any) {
    console.error('‚ùå Error generating types:', error.message);
    if (error.stderr) {
      console.error('stderr:', error.stderr.toString());
    }
    throw error;
  }
}

async function writeTypesFile(typesOutput: string) {
  console.log('üìù Writing types to file...');

  try {
    // Fetch spec info for metadata
    const response = await fetch(OPENAPI_ENDPOINT);
    const spec = await response.json() as ({
      info: {
        version: string;
      };
    })

    // Add header comment with metadata
    const header = `/**
 * Auto-generated TypeScript types from OpenAPI specification
 *
 * Source: ${OPENAPI_ENDPOINT}
 * Generated: ${new Date().toISOString()}
 * OpenAPI Version: ${spec.info?.version || 'unknown'}
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Run 'pnpm sync-types' to regenerate
 */

`;

    const finalOutput = header + typesOutput;

    // Write to output file
    fs.writeFileSync(OUTPUT_FILE, finalOutput, 'utf-8');

    const fileSizeKB = (fs.statSync(OUTPUT_FILE).size / 1024).toFixed(2);
    console.log(`‚úÖ Types written to file`);
    console.log(`   Output: ${OUTPUT_FILE}`);
    console.log(`   Size: ${fileSizeKB} KB`);

    return true;
  } catch (error) {
    console.error('‚ùå Error writing types file:', error);
    throw error;
  }
}

async function main() {
  console.log('üöÄ Starting OpenAPI type synchronization...\n');

  try {
    // Step 1: Check if backend is running
    const isBackendHealthy = await checkBackendHealth();
    if (!isBackendHealthy) {
      process.exit(1);
    }

    console.log('');

    // Step 2: Generate TypeScript types using CLI
    const typesOutput = await generateTypesWithCLI();

    console.log('');

    // Step 3: Write types to file with header
    await writeTypesFile(typesOutput);

    console.log('\n‚ú® Type synchronization completed successfully!\n');
    console.log('üí° You can now import types from:');
    console.log('   import type { paths, components } from \'@/types/api-generated.types\';\n');

    process.exit(0);
  } catch (error) {
    console.error('\n‚ùå Type synchronization failed\n');
    process.exit(1);
  }
}

main();
